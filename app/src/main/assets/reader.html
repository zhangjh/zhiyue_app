<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>电子书阅读器</title>
    <script src="file:///android_asset/jszip.min.js"></script>
    <script src="file:///android_asset/epub.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background: #fafafa;
            overflow: hidden;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            margin-top: env(safe-area-inset-top);
            margin-bottom: env(safe-area-inset-bottom);
        }

        #chapter-title {
            height: 40px;
            line-height: 40px;
            text-align: center;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #eee;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 50px;  /* 增加左右padding，避免与目录按钮重叠 */
        }
        
        /* 调整viewer位置以适应新增的标题栏 */
        #viewer {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #viewer iframe {
            width: 100%;
            height: 100%;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            --text-color: #333;
        }
        
        /* 确保 iframe 内容可以选择文本 */
        #viewer iframe * {
            -webkit-user-select: text !important;
            user-select: text !important;
        }
        
        #selection-menu, #annotation-menu {
            position: fixed;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 8px 0;
            display: none;
            z-index: 9999;
            min-width: 120px;
        }

        #viewer * {
            line-height: 1.6 !important;
            font-size: 1.1em !important;
        }
        #viewer p {
            margin: 1em 0 !important;
            padding: 0 10px !important;
        }
        #progress-container {
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-size: 14px;
            color: #666;
            background: #fafafa;
            position: sticky;
            bottom: 0;
            z-index: 100;
            padding: 5px 0;
            margin-bottom: 10px;
        }
        
        .menu-button {
            width: 100%;
            padding: 8px 16px;
            border: none;
            background: none;
            text-align: center;
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }
        
        .menu-button:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        /* 自定义选中文本的样式 */
        ::selection {
            background: rgba(255,255,0,0.3);
        }

        /* 添加目录样式 */
        #toc-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 80%;
            height: 100%;
            background: white;
            z-index: 1000;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            padding-top: env(safe-area-inset-top); /* 适配刘海屏 */
        }
        
        #toc-header {
            padding: 15px;
            background: #f8f8f8;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 24px;  /* 固定高度确保对齐 */
        }
        
        #toc-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
            font-weight: 500;
            line-height: 24px;  /* 与容器高度一致 */
        }

        #toc-header .close {
            padding: 8px 16px;
            border: none;
            background: none;
            text-align: left;
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }
        
        #toc-header .menu-button {
            padding: 6px 12px;
            color: #666;
            background: none;
            border: none;
            font-size: 14px;
            padding: 4px 12px;
            height: 24px;     /* 与标题高度一致 */
            line-height: 16px;  /* 文字垂直居中 */
            color: #666;
            background: none;
            border: none;
            font-size: 14px;
        }
        
        /* 修改目录内容区样式 */
        #toc-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .toc-item {
            padding: 12px 15px;
            color: #333;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #f5f5f5;
            display: flex;
            align-items: center;
        }
        
        /* 修改目录按钮定位 */
        #toc-button {
            position: absolute;
            top: 5px;
            left: 10px;
            z-index: 999;
            padding: 8px 12px;  /* 调整内边距，让按钮更宽一些 */
            background: white;
            border: 1px solid #eee;
            border-radius: 4px;
            cursor: pointer;
            height: 30px;
            line-height: 14px;
            min-width: 40px;      /* 确保按钮有足够宽度 */
            text-align: center;   /* 文字居中 */
        }

        /* 确保目录容器在打开时正确显示 */
        #toc-container.active {
            transform: translateX(0);
            visibility: visible;
        }
        .toc-item:active {
            background-color: #f0f0f0;
        }

        .toc-item:hover {
            color: #007AFF;
        }
    </style>
</head>
<body>
<div id="chapter-title"></div>
<button id="toc-button">目录</button>
<div id="toc-container">
    <div id="toc-header">
        <h3>目录</h3>
        <button class="close" onclick="closeToc()">关闭</button>
    </div>
    <div id="toc-content"></div>
</div>
<div id="viewer"></div>
<div id="progress-container">阅读进度：0%</div>
<div id="selection-menu">
    <button class="menu-button" id="copy-btn">复制</button>
    <button class="menu-button" id="highlight-btn">高亮</button>
    <button class="menu-button" id="underline-btn">划线</button>
</div>

<div id="annotation-menu">
    <button class="menu-button" id="delete-annotation-btn">删除</button>
</div>

<script>
    let i18n = {};

    let book;
    let rendition;
    let isSelecting = false;
    const annotationMenu = document.getElementById('annotation-menu');
    const selectionMenu = document.getElementById('selection-menu');
    let currentCfiRange = null;
    let currentContents = null;
    let currentAnnotationElement = null;
    let startX, startY;
    let touchStartTime = 0;
    let longPressTimer = null;
    const SWIPE_THRESHOLD = 50;
    const TAP_THRESHOLD = 200;
    const LONG_PRESS_THRESHOLD = 500;

    // 在加载书籍时保存标注数据的数组
    let annotations = [];
    // 添加当前页面引用，用于切换时重新标注
    let currentLocation = null;

    // 应用翻译到HTML元素
    function applyTranslations() {
        if (!i18n || !i18n.reader) return;

        // 更新标题
        document.title = i18n.reader.title;

        // 更新目录按钮和标题
        document.getElementById('toc-button').textContent = i18n.reader.toc;
        document.querySelector('#toc-header h3').textContent = i18n.reader.toc;
        document.querySelector('#toc-header .close').textContent = i18n.reader.close;

        // 更新菜单按钮
        document.getElementById('copy-btn').textContent = i18n.reader.copy;
        document.getElementById('highlight-btn').textContent = i18n.reader.highlight;
        document.getElementById('underline-btn').textContent = i18n.reader.underline;
        document.getElementById('delete-annotation-btn').textContent = i18n.reader.delete;

        // 更新进度文本格式
        updateProgressText();
    }

    // 更新进度文本
    function updateProgressText(percent = 0) {
        if (i18n && i18n.reader) {
            const progressText = i18n.reader.progress.replace('%s', percent);
            document.getElementById('progress-container').textContent = progressText;
        }
    }

    window.setLanguageResource = function(langRes) {
        // console.log("setLangRes: ");
        // console.log(langRes);
        // 应用翻译
        if(langRes) {
            i18n = JSON.parse(langRes);
            // console.log(i18n);
            applyTranslations();
        }
    }

    window.renderAnnotations = function(annotations) {
        if(!annotations || annotations.length <= 0) {
            return;
        }
        // console.log("reRender annotations");
        // 先删除再重新渲染
        annotations.forEach(annotation => {
            if (annotation.type === 'highlight') {
                // console.log("remove highlight");
                rendition.annotations.highlight(
                    annotation.cfi,
                    {},
                    (e) => {
                        e.target.style.backgroundColor = annotation.color || 'rgba(255,255,0,0.3)';
                        // 添加点击事件用于删除
                        e.target.classList.add('annotation-highlight');
                        e.target.setAttribute('data-type', annotation.type);
                        e.target.setAttribute('data-cfi', annotation.cfi);
                        e.target.setAttribute('data-text', annotation.text);
                        e.target.addEventListener('click', handleAnnotationClick);
                        // console.log("add highlight event：" + annotation.text);
                    }
                );
            } else if (annotation.type === 'underline') {
                // console.log("remove underline");
                rendition.annotations.underline(
                    annotation.cfi,
                    {},
                    (e) => {
                        // 添加点击事件用于删除
                        e.target.classList.add('annotation-underline');
                        e.target.setAttribute('data-type', annotation.type);
                        e.target.setAttribute('data-cfi', annotation.cfi);
                        e.target.setAttribute('data-text', annotation.text);
                        e.target.addEventListener('click', handleAnnotationClick);
                        // console.log("add underline event：" + annotation.text);
                    },
                    "ul",
                    {
                        "border": "none",
                        "stroke": annotation.color || "#3366ff",
                        "stroke-width": "2px"
                    }
                );
            }
        });
    }

    // 添加加载已有标注时添加点击事件
    window.loadAnnotations = function(annotationsJson) {
        annotations = JSON.parse(annotationsJson);
        // console.log("annotations init:" + annotationsJson);
        window.renderAnnotations(annotations);
    };

    // 操作处理函数
    function handleCopy() {
        const selection = currentContents.document.getSelection();
        if (selection && window.Android) {
            window.Android.copyText(selection.toString());
        }
        selectionMenu.style.display = 'none';
    }

    async function handleHighlight() {
        if (currentCfiRange) {
            const selection = currentContents.document.getSelection();
            const text = selection.toString();
            annotations.push({
                type: "highlight",
                cfi: currentCfiRange,
                text,
                className: "highlight"
            });
            await rendition.annotations.highlight(currentCfiRange, {}, (e) => {
                e.target.style.backgroundColor = 'rgba(255,255,0,0.3)';
                // 添加点击事件用于删除
                e.target.classList.add('annotation-highlight');
                e.target.setAttribute('data-type', "highlight");
                e.target.setAttribute('data-text', text);
                e.target.setAttribute('data-cfi', currentCfiRange);
                e.target.addEventListener('click', handleAnnotationClick);
            });
            // 保存高亮
            if (window.Android) {
                window.Android.saveAnnotation(
                    currentCfiRange,
                    'highlight',
                    'rgba(255,255,0,0.3)',
                    text
                );
            }
            selectionMenu.style.display = 'none';
        }
    }

    async function handleUnderline() {
        if (currentCfiRange) {
            const selection = currentContents.document.getSelection();
            const text = selection.toString();
            annotations.push({
                type: "underline",
                cfi: currentCfiRange,
                text,
                className: "underline"
            });
            rendition.annotations.underline(currentCfiRange,
                {},
                undefined,
                "ul",
                {
                    "border": "none",
                    "stroke": "#3366ff",
                    "stroke-width": "2px"
                },
                (e) => {
                    // 添加点击事件用于删除
                    e.target.classList.add('annotation-underline');
                    e.target.setAttribute('data-type', "underline");
                    e.target.setAttribute('data-text', text);
                    e.target.setAttribute('data-cfi', currentCfiRange);
                    e.target.addEventListener('click', handleAnnotationClick);
                }
            );
            // 保存下划线
            if (window.Android) {
                window.Android.saveAnnotation(
                    currentCfiRange,
                    'underline',
                    '#3366ff',
                    text
                );
            }
            selectionMenu.style.display = 'none';
        }
    }

    // 添加删除标注处理函数
    function handleDeleteAnnotation() {
        if (currentAnnotationElement) {
            const type = currentAnnotationElement.getAttribute('data-type');
            const cfi = currentAnnotationElement.getAttribute('data-cfi');
            const text = currentAnnotationElement.getAttribute('data-text');
            // console.log("删除标注: cfi:" + cfi + "text:" + text);
            if (cfi && text) {
                // 删除当前
                rendition.annotations.remove(cfi, type);
                // 把要删除的标注从当前缓存里删除(以便重新渲染)
                annotations = annotations.filter(annotation => annotation.text !== text);
                // 通知Android删除标注
                if (window.Android) {
                    window.Android.deleteAnnotation(cfi, text);
                }
                // 删除标注后重新渲染标注
                window.renderAnnotations(annotations);
            }
            // 隐藏菜单
            annotationMenu.style.display = 'none';
            currentAnnotationElement = null;
        }
    }

    // 添加标注点击处理函数
    function handleAnnotationClick(event) {
        event.preventDefault();
        event.stopPropagation();

        // 保存当前点击的标注元素
        currentAnnotationElement = event.target;
        const cfi = currentAnnotationElement.getAttribute('data-cfi');
        const text = currentAnnotationElement.getAttribute('data-text');
        if (!cfi || !text) return;

        // 获取选中文本的位置
        const rect = event.target.getBoundingClientRect();
        const iframe = document.querySelector('#viewer iframe');
        const iframeRect = iframe.getBoundingClientRect();

        // 计算菜单位置
        const menuWidth = annotationMenu.offsetWidth;
        const menuHeight = annotationMenu.offsetHeight;

        // 修改计算方式，使其与划线标注时的计算方式更一致
        let menuLeft = iframeRect.left + rect.left + (rect.width / 2) - (menuWidth / 2) - 20;
        let menuTop = iframeRect.top + rect.top + rect.height - 30;

        // 确保菜单在视口内
        menuLeft = Math.max(10, Math.min(menuLeft, window.innerWidth - menuWidth - 10));
        if (menuTop + menuHeight > window.innerHeight) {
            menuTop = iframeRect.top + rect.top - menuHeight - 30;
        }

        // 显示菜单
        annotationMenu.style.left = `${menuLeft}px`;
        annotationMenu.style.top = `${menuTop}px`;
        annotationMenu.style.display = 'flex';
        annotationMenu.style.justifyContent = 'center';

        // 隐藏选择菜单（如果有）
        selectionMenu.style.display = 'none';
    }

    function initializeSelection() {
        // 添加操作按钮事件监听
        document.body.addEventListener('click', function(e) {
            if (e.target.id === 'copy-btn') handleCopy();
            if (e.target.id === 'highlight-btn') handleHighlight();
            if (e.target.id === 'underline-btn') handleUnderline();
            if (e.target.id === 'delete-annotation-btn') handleDeleteAnnotation();
        });

        // 添加目录按钮点击事件
        document.getElementById('toc-button').addEventListener('click', toggleToc);

        rendition.hooks.content.register((contents) => {
            currentContents = contents;
            const doc = contents.document;

            doc.documentElement.style.webkitUserSelect = 'text';
            doc.documentElement.style.userSelect = 'text';

            // 触摸事件处理
            doc.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                touchStartTime = Date.now();
                isSelecting = false;

                // 添加长按定时器
                longPressTimer = setTimeout(() => {
                    isSelecting = true;
                    // 启用文本选择
                    const range = doc.caretRangeFromPoint(startX, startY);
                    if (range) {
                        const selection = doc.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }, LONG_PRESS_THRESHOLD);
            }, { passive: true });

            doc.addEventListener('touchmove', (e) => {
                // 如果移动距离超过阈值，取消长按定时器
                const moveX = e.touches[0].clientX;
                const moveY = e.touches[0].clientY;
                if (Math.abs(moveX - startX) > SWIPE_THRESHOLD ||
                    Math.abs(moveY - startY) > SWIPE_THRESHOLD) {
                    clearTimeout(longPressTimer);
                }

                if (isSelecting) {
                    const touch = e.touches[0];
                    const range = doc.caretRangeFromPoint(touch.clientX, touch.clientY);
                    const selection = doc.getSelection();

                    if (range && selection.rangeCount > 0) {
                        selection.extend(range.startContainer, range.startOffset);
                    }
                }
            }, { passive: true });

            doc.addEventListener('touchend', () => {
                clearTimeout(longPressTimer);
                // 在选择结束后，添加一个短暂延迟再重置isSelecting
                // 这样可以确保selectionchange事件有足够时间处理
                setTimeout(() => {
                    isSelecting = false;
                }, 300);
            }, { passive: true });

            // 修改选择变化监听
            doc.addEventListener('selectionchange', () => {
                const selection = doc.getSelection();
                const selectedText = selection.toString().trim();

                if (selectedText && isSelecting) {
                    const range = selection.getRangeAt(0);
                    currentCfiRange = contents.cfiFromRange(range);

                    // 获取选中文本的位置
                    const rect = range.getBoundingClientRect();
                    const iframe = document.querySelector('#viewer iframe');
                    const iframeRect = iframe.getBoundingClientRect();

                    // 计算菜单位置
                    const menuWidth = selectionMenu.offsetWidth;
                    const menuHeight = selectionMenu.offsetHeight;

                    let menuLeft = iframeRect.left + rect.left + (rect.width / 2) - (menuWidth / 2);
                    let menuTop = iframeRect.top + rect.bottom + 10;

                    // 确保菜单在视口内
                    menuLeft = Math.max(10, Math.min(menuLeft, window.innerWidth - menuWidth - 10));
                    if (menuTop + menuHeight > window.innerHeight) {
                        menuTop = iframeRect.top + rect.top - menuHeight - 10;
                    }

                    // 显示菜单
                    selectionMenu.style.left = `${menuLeft}px`;
                    selectionMenu.style.top = `${menuTop}px`;
                    selectionMenu.style.display = 'flex';
                }
            });

            // 点击空白区域隐藏菜单
            doc.addEventListener('click', (e) => {
                // 检查点击是否在菜单内
                const isClickInMenu = e.target.closest('#selection-menu') || e.target.closest('#annotation-menu');
                // 如果点击不在菜单内，则隐藏所有菜单
                if (!isClickInMenu) {
                    selectionMenu.style.display = 'none';
                    annotationMenu.style.display = 'none';
                }
            });

            // 阻止上下文菜单
            doc.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
        });
    }

    function loadBook(bookUrl, cfi) {
        let touchStartX;
        //console.log("bookUrl: " + bookUrl);
        book = ePub(bookUrl);
        // 添加错误处理
        book.on('openFailed', function(error) {
            console.error("Failed to open book:", error);
            if (window.Android) {
                const errorMsg = i18n && i18n.reader ? i18n.reader.loading + error.message : "Loading e-book failed: " + error.message;
                window.Android.onLoadError(errorMsg);
            }
        });
        book.loaded.metadata.then(metadata => {
            // 调用Android接口更新书籍信息
            window.Android.onBookMetadata(metadata.title, metadata.creator);
        });
        rendition = book.renderTo("viewer", {
            flow: "paginated",
            width: "100%",
            height: "100%",
            spread: "none",
            minSpreadWidth: 1000
        });

        // 添加位置信息生成代码
        book.ready.then(() => {
            // 添加目录功能
            book.loaded.navigation.then(nav => {
                const toc = nav.toc;
                const tocContent = document.getElementById('toc-content');
                tocContent.innerHTML = '';

                toc.forEach(chapter => {
                    const div = document.createElement('div');
                    div.className = 'toc-item';
                    div.textContent = chapter.label;
                    div.onclick = () => {
                        rendition.display(chapter.href);
                        closeToc();
                    };
                    tocContent.appendChild(div);
                });
            });
            return book.locations.generate();
        }).then(() => {
            rendition.display(cfi || 0);
            
            // 启用手势支持
            rendition.on("touchstart", event => {
                // 只有当不在选择模式时才记录起始位置用于翻页
                if (!isSelecting) {
                    const touches = event.changedTouches[0];
                    touchStartX = touches.screenX;
                }
            });

            rendition.on("touchend", event => {
                // 只有当不在选择模式时才处理翻页
                if (!isSelecting) {
                    const touches = event.changedTouches[0];
                    const swipeDistance = touchStartX - touches.screenX;
                    if (Math.abs(swipeDistance) > 50) {
                        if (swipeDistance > 0) {
                            rendition.next();
                        } else {
                            rendition.prev();
                        }
                    }
                }
            });

            // 添加章节变化监听
            rendition.on('relocated', (location) => {
                currentLocation = location;
                // 获取当前章节信息
                for(let item of book.navigation.toc) {
                    if(item.href.indexOf(location.start.href) !== -1) {
                        let chapterTitle = item.label.trim();
                        document.getElementById('chapter-title').textContent = chapterTitle || '';
                        break;
                    }
                }

                // 确保位置信息已生成后再计算进度
                if (book.locations && book.locations.length() > 0) {
                    let progress = book.locations.percentageFromCfi(location.start.cfi);
                    let progressPercent = Math.round(progress * 100);
                    // console.log("progressPercent: " + progressPercent);
                    updateProgressText(progressPercent);
                    if (window.Android) {
                        window.Android.onProgressUpdate(progressPercent, location.start.cfi);
                    }
                }
                // 重新应用标注(先删除再渲染)
                annotations.forEach(annotation => {
                    if (annotation.type === 'highlight') {
                        // console.log("remove highlight");
                        rendition.annotations.remove(annotation.cfi, annotation.type);
                    } else if (annotation.type === 'underline') {
                        // console.log("remove underline");
                        rendition.annotations.remove(annotation.cfi, annotation.type);
                    }
                });
                window.renderAnnotations(annotations);
            });
        }).then(() => {
            // 位置信息生成完成后，再加载标注
            if (window.Android) {
                window.Android.onBookLoaded();
                window.Android.loadAnnotations();
            }
            initializeSelection();
        });
    }

    // 添加目录控制函数
    function toggleToc() {
        const tocContainer = document.getElementById('toc-container');
        tocContainer.classList.toggle('active');
    }

    function closeToc() {
        const tocContainer = document.getElementById('toc-container');
        tocContainer.classList.remove('active');
    }
</script>
</body>
</html>
